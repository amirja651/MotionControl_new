#include <gtest/gtest.h>

// VERY IMPORTANT: our mock Arduino.h must be found first
#include "Arduino.h"
#include "mae3_encoder_arduino.hpp"  // your production header (unchanged)

using namespace mae3;
using MockArduino::reset;
using MockArduino::triggerEdge;

// Helper: build one edge pair (toff then ton) with period and duty
static void emit_pwm_cycle(int pin, uint32_t start_us, uint32_t toff_us,
                           uint32_t ton_us) {
  // Rising edge ends LOW (captures toff), then falling edge ends HIGH (captures
  // ton)
  triggerEdge(pin, /*level=*/1, start_us + toff_us);           // rising
  triggerEdge(pin, /*level=*/0, start_us + toff_us + ton_us);  // falling
}

class DummyObserver final : public IEncoderObserver {
 public:
  void onPositionUpdate(uint8_t index, uint16_t position) override {
    last_index = index;
    last_position = position;
    called_count++;
  }
  uint8_t last_index{255};
  uint16_t last_position{0};
  uint32_t called_count{0};
};

TEST(MAE3_Encoder_Arduino, MidScale2048) {
  reset();

  constexpr std::size_t N = 1;
  EncoderManager<N> mgr;

  GpioConfig pins[N] = {{4, true, false, false}};
  ASSERT_EQ(mgr.configure(pins), Status::Ok);
  ASSERT_EQ(mgr.setActive(0), Status::Ok);

  // Build a 4.000 ms period: toff=2000us, ton=2000us -> ~50% duty => ~2048
  emit_pwm_cycle(/*pin=*/4, /*t0=*/0, /*toff_us=*/2000, /*ton_us=*/2000);

  DummyObserver obs;
  mgr.attach(&obs);

  mgr.pollAndNotify();

  // Because we attached after the first sample was ready, let's poll again with
  // another cycle
  emit_pwm_cycle(4, 4000, 2000, 2000);
  mgr.pollAndNotify();

  EXPECT_EQ(obs.last_index, 0u);
  // Expect around half-scale. Exact integer may vary; check a band.
  EXPECT_GE(obs.last_position, 2040u);
  EXPECT_LE(obs.last_position, 2056u);
  EXPECT_GE(obs.called_count, 1u);
}

TEST(MAE3_Encoder_Arduino, NearZeroPosition) {
  reset();
  EncoderManager<1> mgr;
  GpioConfig pins[1] = {{5, true, false, false}};
  ASSERT_EQ(mgr.configure(pins), Status::Ok);
  ASSERT_EQ(mgr.setActive(0), Status::Ok);

  // Period ~4096us; ton=1us, toff=4095us
  emit_pwm_cycle(5, 0, 4095, 1);
  DummyObserver obs;
  mgr.attach(&obs);
  mgr.pollAndNotify();

  emit_pwm_cycle(5, 4096, 4095, 1);
  mgr.pollAndNotify();

  EXPECT_LE(obs.last_position, 3u);
}

TEST(MAE3_Encoder_Arduino, NearFullScalePosition) {
  reset();
  EncoderManager<1> mgr;
  GpioConfig pins[1] = {{18, true, false, false}};
  ASSERT_EQ(mgr.configure(pins), Status::Ok);
  ASSERT_EQ(mgr.setActive(0), Status::Ok);

  // Period ~4096us; ton=4090us, toff=6us
  emit_pwm_cycle(18, 0, 6, 4090);
  DummyObserver obs;
  mgr.attach(&obs);
  mgr.pollAndNotify();

  emit_pwm_cycle(18, 4096, 6, 4090);
  mgr.pollAndNotify();

  EXPECT_GE(obs.last_position, 4090u);
}

TEST(MAE3_Encoder_Arduino, InactiveChannelDoesNotInterfere) {
  reset();
  EncoderManager<2> mgr;
  GpioConfig pins[2] = {
      {19, true, false, false},  // idx 0 active
      {21, true, false, false}   // idx 1 inactive
  };
  ASSERT_EQ(mgr.configure(pins), Status::Ok);
  ASSERT_EQ(mgr.setActive(0), Status::Ok);

  DummyObserver obs;
  mgr.attach(&obs);

  // Emit valid cycle on inactive pin 21: ISR will fire, but enabled_ is false
  // -> ignored
  emit_pwm_cycle(21, 0, 2000, 2000);

  // Emit valid cycle on active pin 19
  emit_pwm_cycle(19, 0, 2000, 2000);
  mgr.pollAndNotify();

  EXPECT_EQ(obs.last_index, 0u);
  EXPECT_GE(obs.last_position, 2040u);
  EXPECT_LE(obs.last_position, 2056u);
}

TEST(MAE3_Encoder_Arduino, RejectsInvalidPeriodAndKeepsLastValid) {
  reset();
  EncoderManager<1> mgr;
  GpioConfig pins[1] = {{22, true, false, false}};
  ASSERT_EQ(mgr.configure(pins), Status::Ok);
  ASSERT_EQ(mgr.setActive(0), Status::Ok);

  DummyObserver obs;
  mgr.attach(&obs);

  // First, produce a valid sample around mid-scale
  emit_pwm_cycle(22, 0, 2000, 2000);
  mgr.pollAndNotify();
  const auto first = obs.last_position;

  // Now produce an invalid (too-short) period: e.g., toff=500us, ton=500us =>
  // 1ms
  emit_pwm_cycle(22, 6000, 500, 500);
  mgr.pollAndNotify();

  // Position should remain at last valid (clamped by the implementation)
  EXPECT_EQ(obs.last_position, first);
}
